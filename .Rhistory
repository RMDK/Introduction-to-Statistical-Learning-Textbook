breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
scale_color_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
theme_tufte(10)+ # Make b/w theme
theme(legend.title=element_blank()) # remove legend title
ggplot(data = s1, aes(x=Year, y=value))+
geom_line(aes(color=variable))+
geom_point(aes(shape=variable))+
scale_y_continuous(breaks=seq(0, 0.16, 0.02), labels=c('0%', '2%','4%', '6%','8%', '10%','12%', '14%','16%'))+
scale_x_continuous(breaks=seq(1770, 2010, 20), labels=seq(1770, 2010, 20))+
ylab('Annual rate of return')+
xlab('The pure rate of return to capital is roughly stable around 4%-5% in the long run.\n
Sources and series: see piketty.pse.ens.fr/capital21c.')+
ggtitle('Figure 6.3. The pure return to capital in Britain, 1770-2010')+
scale_shape_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
scale_color_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
theme_fivethirtyeight(10)+ # Make b/w theme
theme(legend.title=element_blank()) # remove legend title
ggplot(data = s1, aes(x=Year, y=value))+
geom_line(aes(color=variable))+
geom_point(aes(shape=variable))+
scale_y_continuous(breaks=seq(0, 0.16, 0.02), labels=c('0%', '2%','4%', '6%','8%', '10%','12%', '14%','16%'))+
scale_x_continuous(breaks=seq(1770, 2010, 20), labels=seq(1770, 2010, 20))+
ylab('Annual rate of return')+
xlab('The pure rate of return to capital is roughly stable around 4%-5% in the long run.\n
Sources and series: see piketty.pse.ens.fr/capital21c.')+
ggtitle('Figure 6.3. The pure return to capital in Britain, 1770-2010')+
scale_shape_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
scale_color_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
theme_fivethirtyeight(10)+ # Make b/w theme
theme(legend.title=element_blank()) # remove legend title
ggplot(data = s1, aes(x=Year, y=value))+
geom_line(aes(color=variable))+
geom_point(aes(shape=variable))+
scale_y_continuous(breaks=seq(0, 0.16, 0.02), labels=c('0%', '2%','4%', '6%','8%', '10%','12%', '14%','16%'))+
scale_x_continuous(breaks=seq(1770, 2010, 20), labels=seq(1770, 2010, 20))+
ylab('Annual rate of return')+
xlab('The pure rate of return to capital is roughly stable around 4%-5% in the long run.\n
Sources and series: see piketty.pse.ens.fr/capital21c.')+
ggtitle('Figure 6.3. The pure return to capital in Britain, 1770-2010')+
scale_shape_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
scale_color_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
theme_element(10)+ # Make b/w theme
theme(legend.title=element_blank()) # remove legend title
ggplot(data = s1, aes(x=Year, y=value))+
geom_line(aes(color=variable))+
geom_point(aes(shape=variable))+
scale_y_continuous(breaks=seq(0, 0.16, 0.02), labels=c('0%', '2%','4%', '6%','8%', '10%','12%', '14%','16%'))+
scale_x_continuous(breaks=seq(1770, 2010, 20), labels=seq(1770, 2010, 20))+
ylab('Annual rate of return')+
xlab('The pure rate of return to capital is roughly stable around 4%-5% in the long run.\n
Sources and series: see piketty.pse.ens.fr/capital21c.')+
ggtitle('Figure 6.3. The pure return to capital in Britain, 1770-2010')+
scale_shape_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
scale_color_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
theme_economist(10)+ # Make b/w theme
theme(legend.title=element_blank()) # remove legend title
ggplot(data = s1, aes(x=Year, y=value))+
geom_line(aes(color=variable))+
geom_point(aes(shape=variable))+
scale_y_continuous(breaks=seq(0, 0.16, 0.02), labels=c('0%', '2%','4%', '6%','8%', '10%','12%', '14%','16%'))+
scale_x_continuous(breaks=seq(1770, 2010, 20), labels=seq(1770, 2010, 20))+
ylab('Annual rate of return')+
xlab('The pure rate of return to capital is roughly stable around 4%-5% in the long run.\n
Sources and series: see piketty.pse.ens.fr/capital21c.')+
ggtitle('Figure 6.3. The pure return to capital in Britain, 1770-2010')+
scale_shape_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
scale_color_discrete(name='',
breaks=c('Observed', 'Pure'),
labels=c('Observed average rate of return to capital',
'Pure rate of return to capital (estimate)'))+
theme_bw(10)+ # Make b/w theme
theme(legend.title=element_blank()) # remove legend title
install.packages('ggvis')
install.packages('rCharts')
library(rCharts)
attach(Auto)
library(ISLR)
attach(Auto)
set.seed(1)
train = sample(392, 196)
lm.fit <- lm(mpg ~ horsepower, data=Auto, subset=train)
mean((mpg - predict(lm.fot, Auto))[-train]^2)
mean((mpg - predict(lm.ftt, Auto))[-train]^2)
mean((mpg - predict(lm.fit, Auto))[-train]^2)
lm.git2 <- lm(mpg ~ poly(horsepower, 2), sata=Auto, subset = train)
mean((mpg - predict(lm.fit2, Auto))[-train]^2
lm.git2 <- lm(mpg ~ poly(horsepower, 2), data=Auto, subset = train)
lm.fit2 <- lm(mpg ~ poly(horsepower, 2), data=Auto, subset = train)
mean((mpg - predict(lm.fit2, Auto))[-train]^2
mean((mpg - predict(lm.fit2, Auto))[-train]^2)
```
mean((mpg - predict(lm.fit2, Auto))[-train]^2)
lm.fit3 <- lm(mpg ~ poly(horsepower, 3), data=Auto, subset = train)
mean((mpg - predict(lm.fit2=3, Auto))[-train]^2)
lm.fit3 <- lm(mpg ~ poly(horsepower, 3), data=Auto, subset = train)
mean((mpg - predict(lm.fit2=3, Auto))[-train]^2)
mean((mpg - predict(lm.fit3, Auto))[-train]^2)
library(ggplot2)
gdURL <- "http://www.stat.ubc.ca/~jenny/notOcto/STAT545A/examples/gapminder/data/gapminderDataFiveYear.txt"
gDat <- read.delim(file = gdURL)
str(gDat)
ggplot(gDat, aes(x = gdpPercap, y = lifeExp)) # error!
p <- ggplot(gDat, aes(x = gdpPercap, y = lifeExp)) # just initializes
p + layer(geom = "point")
p + geom_point()
ggplot(gDat, aes(x = log10(gdpPercap), y = lifeExp)) + geom_point()
p + geom_point() + scale_x_log10()
ggplot(gDat, aes(x = continent)) + geom_bar()
ggplot(gDat, aes(x = continent), stat="bin") + geom_bar()
ggplot(gDat, aes(x = continent)) + layer(stat="bin")
ggplot(gDat, aes(x = continent, y = country)) + layer(stat="sum")
ggplot(gDat, aes(x = continent, y = country)) + stat_sum()
ggplot(gDat, aes(x = continent)) + geom_bar()
ggplot(gDat, aes(x = continent), stat="bin") + geom_bar()
ggplot(gDat, aes(x = continent)) + layer(stat="bin")
ggplot(gDat, aes(x = continent, y = country)) + layer(stat="sum")
head(gDat)
library(plyr)
ggplot(gDat, aes(x = continent)) + geom_bar()
gDat[gDat$continent='Asia']$country
gDat[gDat$continent=='Asia']$country
gDat[gDat$continent=='Asia']
gDat$continent
gDat$continent=='Asia'
gDat$country[gDat$continent=='Asia']
ggplot(gDat, aes(x = levels(continent), y = levels(country))) + stat_sum()
ggplot(gDat, aes(x = continent, y = country)) + stat_summary(fun.y = levels(country))
ggplot(gDat, aes(x = continent, y = country)) + stat_summary(fun.y = sum(levels(gDat$country)))
## still not exactly what I want; how to count countries within continent?
ggplot(gDat, aes(x = continent, y = country)) + stat_summary(fun.y = sum(levels(gDat$country)))
ggplot(gDat, aes(x = continent, y = country)) + stat_summary(fun.y = (levels(gDat$country)))
## still not exactly what I want; how to count countries within continent?
ggplot(gDat, aes(x = continent, y = country)) + stat_summary(fun.y = as.character(levels(gDat$country)))
levels(gDat$country)
ggplot(gDat, aes(x = continent, y = country)) + stat_summary(fun.y = levels(gDat$country))
ggplot(gDat, aes(x = continent, y = country)) + layer(stat="sum")
ggplot(gDat, aes(x = continent)) + layer(stat="bin")
ggplot(gDat, aes(x = continent, y = country)) +
stat_summary(fun.y = function(continent = x) {
return sum(levels(gDat$country[gDat$continent==x]))
## still not exactly what I want; how to count countries within continent?
ggplot(gDat, aes(x = continent, y = country)) +
stat_summary(fun.y = function(continent = x) {
return(sum(levels(gDat$country[gDat$continent==x])))
## still not exactly what I want; how to count countries within continent?
ggplot(gDat, aes(x = continent, y = country)) +
stat_summary(fun.y = function(continent = x) {
return(sum(levels(gDat$country[gDat$continent==x])))})
## still not exactly what I want; how to count countries within continent?
ggplot(gDat, aes(x = continent, y = country)) + geom_bar()
ggplot(gDat, aes(x = continent, y = country))+
geom_bar()
ggplot(gDat, aes(x = continent, y = country))+
geom_bar()
ggplot(gDat, aes(x = continent))+
geom_bar(stat='identity')
ggplot(gDat, aes(x = continent))+
geom_bar(stat='identity')
ggplot(gDat, aes(x = continent))+
geom_bar(stat='bin')
gDat$country[gDat$continent=='Asia']
unique(gDat$country[gDat$continent=='Asia'])
levels(gDat$country[gDat$continent=='Asia'])
sum(levels(gDat$country[gDat$continent=='Asia']))
count(levels(gDat$country[gDat$continent=='Asia']))
dim(levels(gDat$country[gDat$continent=='Asia']))
table(levels(gDat$country[gDat$continent=='Asia']))
length(levels(gDat$country[gDat$continent=='Asia']))
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = function(x) {
return length(levels(y))
})
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = function() {
return(length(levels(y)))
})
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = levels)
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = unique)
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = length)
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = sum)
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = count)
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = table)
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = table, geom='bar')
ggplot(gDat, aes(x = continent, y=country))+
stat_summary(fun.y = sum, geom='bar')
unique(gDat )
ggplot(gDat, aes(x = continent)) + geom_bar()
ggplot(unique(gDat), aes(x = continent)) + geom_bar()
ggplot(gDat, aes(x = continent)) + stat_summary(fun.y=length(levels(country)), geom='bar')
ggplot(gDat, aes(x = continent)) + stat_summary(fun.y=length(levels(gDatcountry)), geom='bar')
ggplot(gDat, aes(x = continent)) + stat_summary(fun.y=length(levels(gDat$country)), geom='bar')
ggplot(gDat, aes(x = continent)) + stat_summary(fun.y=length(levels(gDat$country)), geom='bar', stat'bin')
ggplot(gDat, aes(x = continent, y=country)) + stat_summary(fun.y=length(levels(gDat$country)), geom='bar')
ggplot(gDat, aes(x = continent)) + stat_summary(fun.y=length(levels(gDat$country)), geom='bar', stat='identity')
ggplot(gDat, aes(x = continent, y=levels(unique(country)))) + geom_bar()
library(ISLR)
attach(Auto)
set.seed(1)
train = sample(392, 196)
lm.fit <- lm(mpg ~ horsepower, data=Auto, subset=train)
# Predict and calculate MSE of the validation set.
mean((mpg - predict(lm.fit, Auto))[-train]^2)
lm.fit2 <- lm(mpg ~ poly(horsepower, 2), data=Auto, subset = train)
mean((mpg - predict(lm.fit2, Auto))[-train]^2)
lm.fit3 <- lm(mpg ~ poly(horsepower, 3), data=Auto, subset = train)
mean((mpg - predict(lm.fit3, Auto))[-train]^2)
set.seed(2)
train <- sample(392, 196)
lm.fit <- lm(mpg ~ horsepower, subset=train)
mean((mpg - predict(lm.fit, Auto))[-train]^2)
glm.fit <- glm(mpg ~ horsepower, data=Auto)
coef(glm.fit)
library(boot)
cv.err <- cv.glm(Auto, glm.fit)
cv.err$delta
summary(cv.err)
cv.err <- rep(0, 5)
for (i in 1:5) {
glm.fit <- glm(mpg ~ poly(horsepower, i), data=Auto)
cv.err[i] <- cv.glm(Auto, glm.fit)$delta[1]
}
cv.err
set.seed(17) # For reproduction
cv.err <- rep(0, 10)
for (i in 1:10) {
glm.fit <- glm(mpg ~ poly(horsepower, i), data=Auto)
cv.err[i] <- cv.glm(Auto, glm.fit, K=10)$delta[1]
}
cv.err
system.time(for (i in 1:10) {
glm.fit <- glm(mpg ~ poly(horsepower, i), data=Auto)
cv.err[i] <- cv.glm(Auto, glm.fit, K=10)$delta[1]
})
index
boot.fn <- function(data, index) {
return(coef(lm(mpg ~ horsepower, data=Auto, subset = index)))
}
boot.fn(Auto, 1:392)
boot.fn(Auto, sample(392, 392, replace = T))
sample
help(sample)
sample(392, 392)
sample(10)
sample(10, 10)
sample(10, 1)
sample(10, 2)
boot.fn(Auto, sample(x=392, n=392, replace = T))
boot.fn(Auto, sample(x=392, size=392, replace = T))
boot(Auto, boot.fn, 1000)
summary(lm(mpg ~ horsepower, data=Auto))$coef
library(ISLR)
attach(Hitters)
names(Hitters)
str(Hitters)
sum(is.na(Hitters$Salary))
dim(Hitters)
sum(is.na(Hitters$Salary))/length(Hitters[,1])
length(Hitters)
length(Hitters[,1])
Hitters <- na.omit(Hitters)
dim(Hitters)
library(leaps)
regfit <- regsubsets(Salary ~ ., Hitters)
summary(regfit)
summary(regfit)$rsq
regfit <- regsubsets(Salary ~ ., data=Hitters, nvmax = 19)
summary(regfit)$rsq
plot(regfit, scale = 'r2')
plot(regfit, scale= 'adjr2')
plot(regfit, scale = 'r2')
str(regfit)
summary(regfit)
summary(regfit)$rss
plot(regfit, scale = 'r2')
library(caret)
inTrain<- createDataPartition(y=Salary, p = 0.7, list = FALSE)
sum(is.na(Hitters))
inTrain<- createDataPartition(y=Hitters$Salary, p = 0.7, list = FALSE)
train <- Hitters[inTrain,]
test <- Hitters[-inTrain,]
regfit <- regsubsets(Salary ~ ., train)
summary(regfit)
regfit <- regsubsets(Salary ~ ., data=train, nvmax = 19)
summary(regfit)$rsq
plot(regfit, scale = 'r2')
regfit.pred <- predict(regfit, test)
regfit
regfit <- regsubsets(Salary ~ ., data=train, nvmax = 19)
summary(regfit)
regfit.pred <- predict(summary(regfit), test)
summary(regfit)
names(summary(regfit))
summary(regfit)$obj
summary(regfit)$which
summary(regfit)$outmatch
summary(regfit)$outmat
str(regfit)
regfit <- regsubsets(Salary ~ ., Hitters)
summary(regfit)
regfit <- regsubsets(Salary ~ ., data=Hitters, nvmax = 19)
summary(regfit)$rsq
inTrain <- createDataPartition(y=Hitters$Salary, p=0.6, list=FALSE)
train <- Hitters[inTrain,]
test <- Hitters[-inTrain,]
regfit <- regsubsets(Salary ~ ., train)
summary(regfit)
regfit <- regsubsets(Salary ~ ., data=Hitters, nvmax = 19)
pred.regsub <- function( object, newdata, id, ...) {
form=as.formula(object$call [[2]])
mat=model.matrix(form,newdata)
coefi=coef(object ,id=id)
xvars=names(coefi)
mat[,xvars]%*%coefi
}
regfit.pred <- predict(regfit, test)
regfit.pred <- pred.regsub(regfit, test)
regfit <- regsubsets(Salary ~ ., Hitters)
summary(regfit)
regfit <- regsubsets(Salary ~ ., data=Hitters, nvmax = 19)
summary(regfit)$rsq
regfit.fwd <- regsubsets(Salary ~., data=Hitters, nvmax=19)
regfit.bwd <- regsubsets(Salary ~., data=Hitters, nvmax=19)
train(Salary ~., data=Hitters, method='regsubsets')
train(Salary ~., data=Hitters, method='regsubset')
split <- createDataPartition(y = Hitters$Salary, p = 0.5, list=FALSE)
regfit <- regsubsets(Salary ~., data=train, nvmax = 19)
test.m <- model.matrix(Salary~., data=test)
val.errors <- rep(NA, 19)
regfit <- regsubsets(Salary ~., data=train, nvmax = 19)
val.errors <- rep(NA, 19)
for (i in 1:19) {
coefi <- coef(regfit, id=i)
pred <- test.m[,names(coef)]%*%coefi
val.errors[i] <- mean((Hitters$Salary[test]-pred)^2)
}
val.errors <- rep(NA, 19)
for (i in 1:19) {
coefi <- coef(regfit, id=i)
pred <- test.m[,names(coef)]%*%coefi
val.errors[i] <- mean((test$Salary-pred)^2)
}
val.errors
test$Salary
pred
test.m <- model.matrix(Salary~., data=test)
for (i in 1:19) {
coefi <- coef(regfit, id=i)
# 2.0
pred <- test.m[,names(coef)]%*%coefi
# 3.0
val.errors[i] <- mean((test$Salary-pred)^2)
}
val.errors <- rep(NA, 19)
#1.0
for (i in 1:19) {
coefi <- coef(regfit, id=i)
# 2.0
pred <- test.m[,names(coef)]%*%coefi
# 3.0
val.errors[i] <- mean((test$Salary-pred)^2)
}
val.errors
test.m
test.m[,names(coefi)]
test.m[,names(coefi)]%*%coefi
coefi <- coef(regfit, id=i)
coefi
for (i in 1:19) {
coefi <- coef(regfit, id=i)
# 2.0
pred <- test.m[,names(coef)]%*%coefi
# 3.0
val.errors[i] <- mean((test$Salary-pred)^2)
}
val.errors
mean((test$Salary-pred)^2)
pred
test.m[,names(coef)]%*%coefi
i
val.errors <- rep(NA, 18)
for (i in 1:18) {
coefi <- coef(regfit, id=i)
# 2.0
pred <- test.m[,names(coef)]%*%coefi
# 3.0
val.errors[i] <- mean((test$Salary-pred)^2)
}
```
val.errors
val.errors <- rep(NA, 19)
#1.0
for (i in 1:19) {
coefi <- coef(regfit, id=i)
# 2.0
pred <- test.m[,names(coef)]%*%coefi
# 3.0
val.errors[i] <- mean((test$Salary-pred)^2)
}
pred
str(pred)
for (i in 1:19) {
coefi <- coef(regfit, id=i)
# 2.0
pred <- test.m[,names(coefi)]%*%coefi
# 3.0
val.errors[i] <- mean((test$Salary-pred)^2)
}
val.errors
which.min(val.errors)
coef(regfig, 7)
coef(regfit, 7)
regfit <- regsubsets(Salary ~., data=Hitters, nvmax=19)
coef(regfit, 10)
ridge <- train(Salary~., data = Hitters,
method='ridge'
preProcess=c('center', 'scale'))
ridge <- train(Salary~., data = Hitters,
method='ridge',
preProcess=c('center', 'scale'))
summary(ridge)
summary(ridge)$lambda
ridge$lambda
ridge
fitControl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 10,
## Estimate class probabilities
classProbs = TRUE,
## Evaluate performance using
## the following function
summaryFunction = twoClassSummary)
set.seed(825)
ridge <- train(Salary~., data = Hitters,
method='ridge',
trControl = fitControl,
preProcess=c('center', 'scale'))
install.packages('pROC')
ridge <- train(Salary~., data = Hitters,
method='ridge',
trControl = fitControl,
preProcess=c('center', 'scale'))
fitControl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 10,
## Evaluate performance using
## the following function
summaryFunction = twoClassSummary)
set.seed(825)
ridge <- train(Salary~., data = Hitters,
method='ridge',
trControl = fitControl,
preProcess=c('center', 'scale'))
fitControl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 10)
set.seed(825)
ridge <- train(Salary~., data = Hitters,
method='ridge',
trControl = fitControl,
preProcess=c('center', 'scale'))
ridge
knnGrid <- expand.grid(.k=c(2))
knnGrid
lambdaGrid <- expand.grid(.lamda<- 10^seq(10, -2, length=100)
ridge <- train(Salary~., data = Hitters,
method='ridge',
trControl = fitControl,
ridge <- train(Salary~., data = Hitters,
method='ridge',
trControl = fitControl,
tuneGrid = lamdaGrid,
preProcess=c('center', 'scale'))
lambdaGrid <- expand.grid(.lamda<- 10^seq(10, -2, length=100)
